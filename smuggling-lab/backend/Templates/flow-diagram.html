<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HTTP Request Smuggling + Cache Poisoning ‚Äî Flow Diagram</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Rajdhani:wght@400;600;700&display=swap');

  :root {
    --bg: #0a0c0f;
    --panel: #0f1318;
    --border: #1e2830;
    --red: #ff3b3b;
    --green: #00ff88;
    --blue: #00aaff;
    --yellow: #ffcc00;
    --orange: #ff7a00;
    --text: #c8d8e8;
    --dim: #4a5a6a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Rajdhani', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Grid background */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,170,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,170,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    max-width: 1100px;
    margin: 0 auto;
    padding: 40px 20px;
  }

  header {
    text-align: center;
    margin-bottom: 50px;
  }

  header h1 {
    font-size: 2.2rem;
    font-weight: 700;
    color: #fff;
    letter-spacing: 2px;
    text-transform: uppercase;
  }

  header h1 span { color: var(--red); }

  header p {
    font-family: 'Share Tech Mono', monospace;
    color: var(--dim);
    font-size: 0.85rem;
    margin-top: 8px;
    letter-spacing: 1px;
  }

  /* Tab buttons */
  .tabs {
    display: flex;
    gap: 8px;
    justify-content: center;
    margin-bottom: 40px;
    flex-wrap: wrap;
  }

  .tab {
    padding: 10px 24px;
    border: 1px solid var(--border);
    background: var(--panel);
    color: var(--dim);
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: 1px;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    clip-path: polygon(8px 0%, 100% 0%, calc(100% - 8px) 100%, 0% 100%);
  }

  .tab:hover { border-color: var(--blue); color: var(--blue); }
  .tab.active { background: var(--blue); color: #000; border-color: var(--blue); }
  .tab.red.active { background: var(--red); border-color: var(--red); }
  .tab.green.active { background: var(--green); border-color: var(--green); }

  /* Content panels */
  .panel { display: none; }
  .panel.active { display: block; }

  /* Architecture diagram */
  .arch {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 0;
    flex-wrap: wrap;
    margin: 20px 0 40px;
  }

  .node {
    background: var(--panel);
    border: 1px solid var(--border);
    padding: 20px 24px;
    text-align: center;
    min-width: 130px;
    position: relative;
    transition: all 0.3s;
  }

  .node:hover {
    border-color: var(--blue);
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(0,170,255,0.15);
  }

  .node .icon { font-size: 2rem; display: block; margin-bottom: 8px; }
  .node .label { font-size: 1.1rem; font-weight: 700; color: #fff; letter-spacing: 1px; }
  .node .sublabel { font-family: 'Share Tech Mono', monospace; font-size: 0.7rem; color: var(--dim); margin-top: 4px; }
  .node .port { font-family: 'Share Tech Mono', monospace; font-size: 0.75rem; color: var(--yellow); margin-top: 6px; }

  .node.attacker { border-color: var(--red); }
  .node.attacker .label { color: var(--red); }
  .node.haproxy { border-color: var(--orange); }
  .node.haproxy .label { color: var(--orange); }
  .node.varnish { border-color: var(--blue); }
  .node.varnish .label { color: var(--blue); }
  .node.flask { border-color: var(--green); }
  .node.flask .label { color: var(--green); }

  .arrow {
    display: flex;
    align-items: center;
    padding: 0 8px;
    color: var(--dim);
    font-size: 1.5rem;
  }

  /* Steps */
  .steps { display: flex; flex-direction: column; gap: 16px; }

  .step {
    display: flex;
    gap: 20px;
    align-items: flex-start;
    background: var(--panel);
    border: 1px solid var(--border);
    border-left: 3px solid var(--dim);
    padding: 20px;
    cursor: pointer;
    transition: all 0.3s;
  }

  .step:hover { border-left-color: var(--blue); background: #111820; }
  .step.active { border-left-color: var(--red); background: #140a0a; }
  .step.defense { border-left-color: var(--green) !important; background: #0a140a !important; }

  .step-num {
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.4rem;
    font-weight: bold;
    min-width: 40px;
    color: var(--dim);
  }

  .step.active .step-num { color: var(--red); }
  .step.defense .step-num { color: var(--green); }

  .step-content h3 {
    font-size: 1.1rem;
    font-weight: 700;
    color: #fff;
    margin-bottom: 6px;
    letter-spacing: 1px;
  }

  .step-content p {
    color: var(--dim);
    font-size: 0.95rem;
    line-height: 1.5;
  }

  .step-content .code {
    font-family: 'Share Tech Mono', monospace;
    background: #050708;
    border: 1px solid var(--border);
    padding: 12px;
    margin-top: 10px;
    font-size: 0.78rem;
    color: var(--green);
    line-height: 1.6;
    display: none;
  }

  .step.active .code, .step.defense .code { display: block; }
  .step.active .step-content p, .step.defense .step-content p { color: var(--text); }

  /* Tags */
  .tag {
    display: inline-block;
    padding: 2px 8px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.7rem;
    margin-right: 6px;
    margin-bottom: 4px;
  }

  .tag.red { background: rgba(255,59,59,0.15); color: var(--red); border: 1px solid rgba(255,59,59,0.3); }
  .tag.green { background: rgba(0,255,136,0.1); color: var(--green); border: 1px solid rgba(0,255,136,0.2); }
  .tag.blue { background: rgba(0,170,255,0.1); color: var(--blue); border: 1px solid rgba(0,170,255,0.2); }
  .tag.yellow { background: rgba(255,204,0,0.1); color: var(--yellow); border: 1px solid rgba(255,204,0,0.2); }

  /* Limits section */
  .limits-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 16px;
  }

  .limit-card {
    background: var(--panel);
    border: 1px solid var(--border);
    padding: 20px;
    transition: all 0.3s;
  }

  .limit-card:hover {
    border-color: var(--yellow);
    box-shadow: 0 4px 20px rgba(255,204,0,0.08);
  }

  .limit-card h3 {
    font-size: 1rem;
    font-weight: 700;
    color: var(--yellow);
    letter-spacing: 1px;
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .limit-card p {
    color: var(--dim);
    font-size: 0.9rem;
    line-height: 1.6;
  }

  /* Section title */
  .section-title {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem;
    color: var(--dim);
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
  }

  .section-title span { color: var(--blue); }
</style>
</head>
<body>
<div class="container">

  <header>
    <h1>HTTP Request <span>Smuggling</span> + Cache Poisoning</h1>
    <p>// Web Security Final Project ‚Äî Attack & Defense Flow Diagram</p>
  </header>

  <!-- Tabs -->
  <div class="tabs">
    <button class="tab active" onclick="showTab('arch')">Architecture</button>
    <button class="tab red" onclick="showTab('attack')">Attack Flow</button>
    <button class="tab green" onclick="showTab('defense')">Defense Flow</button>
    <button class="tab" onclick="showTab('limits')">Limitations</button>
  </div>

  <!-- ARCHITECTURE -->
  <div id="arch" class="panel active">
    <div class="section-title">// <span>System Architecture</span> ‚Äî 3-Tier Stack</div>

    <div class="arch">
      <div class="node attacker">
        <span class="icon">üíÄ</span>
        <div class="label">Attacker</div>
        <div class="sublabel">Python Script</div>
        <div class="port">Raw Socket</div>
      </div>
      <div class="arrow">‚Üí</div>
      <div class="node haproxy">
        <span class="icon">üîÄ</span>
        <div class="label">HAProxy</div>
        <div class="sublabel">Reverse Proxy</div>
        <div class="port">:80</div>
      </div>
      <div class="arrow">‚Üí</div>
      <div class="node varnish">
        <span class="icon">üíæ</span>
        <div class="label">Varnish</div>
        <div class="sublabel">HTTP Cache</div>
        <div class="port">:6081</div>
      </div>
      <div class="arrow">‚Üí</div>
      <div class="node flask">
        <span class="icon">üêç</span>
        <div class="label">Flask</div>
        <div class="sublabel">Backend API</div>
        <div class="port">:5000</div>
      </div>
    </div>

    <div class="steps">
      <div class="step active">
        <div class="step-num">01</div>
        <div class="step-content">
          <h3>HAProxy ‚Äî Reverse Proxy (Front-End)</h3>
          <p>Receives all incoming HTTP requests on port 80. Forwards them to Varnish. In vulnerable mode: passes both Content-Length and Transfer-Encoding headers without validation.</p>
          <div class="code">
<span style="color:var(--orange)">// Vulnerable behavior:</span>
POST / HTTP/1.1
Content-Length: 50        <span style="color:var(--red)">‚Üê HAProxy uses this</span>
Transfer-Encoding: chunked <span style="color:var(--red)">‚Üê HAProxy ignores this</span>

<span style="color:var(--orange)">// HAProxy thinks: one request of 50 bytes ‚úì</span>
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-num">02</div>
        <div class="step-content">
          <h3>Varnish ‚Äî HTTP Cache (Middle Layer)</h3>
          <p>Caches responses for /api/* endpoints. Cache key is based on URL path only ‚Äî not on auth headers. This allows poisoned responses to be served to all users.</p>
          <div class="code">
<span style="color:var(--blue)">// Cache key (vulnerable):</span>
hash_data(req.url);  <span style="color:var(--red)">‚Üê path only!</span>

<span style="color:var(--blue)">// Result: /api/user always returns same cached response</span>
<span style="color:var(--red)">// regardless of who is asking</span>
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-num">03</div>
        <div class="step-content">
          <h3>Flask ‚Äî Backend API (Back-End)</h3>
          <p>The real application server. In vulnerable mode: honors Transfer-Encoding: chunked and stops reading at the chunk terminator (0\r\n\r\n), leaving smuggled bytes in the TCP buffer.</p>
          <div class="code">
<span style="color:var(--green)">// Flask reads chunked body and stops at:</span>
0\r\n\r\n  <span style="color:var(--yellow)">‚Üê end of chunked body</span>

<span style="color:var(--red)">// Bytes after this = smuggled next request!</span>
GET /admin HTTP/1.1\r\n...  <span style="color:var(--red)">‚Üê stays in buffer</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ATTACK FLOW -->
  <div id="attack" class="panel">
    <div class="section-title">// <span>Attack Flow</span> ‚Äî CL.TE Smuggling + Cache Poisoning</div>

    <div class="steps">
      <div class="step active">
        <div class="step-num">01</div>
        <div class="step-content">
          <span class="tag red">SMUGGLING</span><span class="tag yellow">CL.TE</span>
          <h3>Build Malicious Payload</h3>
          <p>Attacker crafts a request with BOTH Content-Length and Transfer-Encoding headers. This creates a parsing ambiguity between HAProxy and Flask.</p>
          <div class="code">
POST / HTTP/1.1
Host: localhost
Content-Length: 44        <span style="color:var(--orange)">‚Üê HAProxy reads this (covers everything)</span>
Transfer-Encoding: chunked <span style="color:var(--red)">‚Üê Flask reads this</span>
Connection: keep-alive

1\r\n
X\r\n
0\r\n
\r\n
<span style="color:var(--red)">GET /admin HTTP/1.1\r\n  ‚Üê SMUGGLED REQUEST</span>
<span style="color:var(--red)">X-Admin-Auth: secret-token\r\n</span>
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-num">02</div>
        <div class="step-content">
          <span class="tag red">DESYNC</span>
          <h3>Parsing Desynchronization</h3>
          <p>HAProxy and Flask disagree on where the request ends. HAProxy forwards everything as one request. Flask stops at the chunked terminator ‚Äî leaving the smuggled GET /admin in the TCP buffer.</p>
          <div class="code">
<span style="color:var(--orange)">HAProxy sees:</span>  1 request (POST /)
<span style="color:var(--green)">Flask sees:</span>     1 request (POST /) + leftover bytes

<span style="color:var(--red)">TCP buffer now contains:</span>
GET /admin HTTP/1.1
X-Admin-Auth: secret-token
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-num">03</div>
        <div class="step-content">
          <span class="tag red">POISON</span><span class="tag blue">CACHE</span>
          <h3>Cache Poisoning via Smuggled Request</h3>
          <p>500ms later, a "victim" GET /api/user arrives. Flask processes the smuggled GET /admin FIRST (from buffer), gets the admin response, which Varnish caches under the key /api/user.</p>
          <div class="code">
<span style="color:var(--blue)">Victim sends:</span>  GET /api/user
<span style="color:var(--red)">Flask processes:</span> GET /admin (smuggled!) ‚Üí admin response
<span style="color:var(--blue)">Varnish caches:</span> admin response under key "/api/user"

<span style="color:var(--red)">Result: ALL users get admin data!</span>
{"role":"admin","secret_key":"XK9#mP2$"} ‚Üê üò±
          </div>
        </div>
      </div>

      <div class="step">
        <div class="step-num">04</div>
        <div class="step-content">
          <span class="tag red">IMPACT</span>
          <h3>All Users Receive Poisoned Response</h3>
          <p>Every subsequent request to /api/user returns the poisoned admin response from cache ‚Äî until the cache TTL expires (300 seconds) or the cache is manually purged.</p>
          <div class="code">
User1 ‚Üí GET /api/user ‚Üí <span style="color:var(--red)">{"role":"admin","secret_key":"XK9#mP2$"}</span>
User2 ‚Üí GET /api/user ‚Üí <span style="color:var(--red)">{"role":"admin","secret_key":"XK9#mP2$"}</span>
User3 ‚Üí GET /api/user ‚Üí <span style="color:var(--red)">{"role":"admin","secret_key":"XK9#mP2$"}</span>

x-cache: HIT (POISONED) ‚Üê Varnish serving from cache
TTL: 300 seconds remaining
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- DEFENSE FLOW -->
  <div id="defense" class="panel">
    <div class="section-title">// <span>Defense Flow</span> ‚Äî How Attacks Are Blocked</div>

    <div class="steps">
      <div class="step defense">
        <div class="step-num">D1</div>
        <div class="step-content">
          <span class="tag green">FLASK</span><span class="tag blue">BACKEND</span>
          <h3>Block Transfer-Encoding at Backend</h3>
          <p>In secure mode, Flask rejects any request containing Transfer-Encoding: chunked. Legitimate requests through the proxy chain should never have this header reach the backend.</p>
          <div class="code">
<span style="color:var(--green)">if "chunked" in Transfer-Encoding:</span>
    return 400 "Transfer-Encoding not permitted"

<span style="color:var(--green)">if Content-Length AND Transfer-Encoding both present:</span>
    return 400 "Ambiguous framing rejected"

<span style="color:var(--green)">Result: smuggling payload blocked immediately ‚úì</span>
          </div>
        </div>
      </div>

      <div class="step defense">
        <div class="step-num">D2</div>
        <div class="step-content">
          <span class="tag green">VARNISH</span><span class="tag blue">CACHE</span>
          <h3>Auth-Aware Cache Keys</h3>
          <p>Secure Varnish config includes authentication headers in the cache key. Different users get different cache entries ‚Äî poisoning one user's cache doesn't affect others.</p>
          <div class="code">
<span style="color:var(--green)">// Secure cache key:</span>
hash_data(req.url);
hash_data(req.http.Authorization);  <span style="color:var(--green)">‚Üê added!</span>
hash_data(req.http.Cookie);         <span style="color:var(--green)">‚Üê added!</span>

<span style="color:var(--green)">Result: each user has isolated cache entry ‚úì</span>
          </div>
        </div>
      </div>

      <div class="step defense">
        <div class="step-num">D3</div>
        <div class="step-content">
          <span class="tag green">HAPROXY</span><span class="tag blue">PROXY</span>
          <h3>Reject Ambiguous Requests at Proxy</h3>
          <p>Secure HAProxy config rejects requests with both CL and TE headers before they even reach the backend ‚Äî stopping the attack at the first layer.</p>
          <div class="code">
<span style="color:var(--green)">acl has_cl  hdr_cnt(Content-Length) gt 0</span>
<span style="color:var(--green)">acl has_te  hdr_cnt(Transfer-Encoding) gt 0</span>
<span style="color:var(--green)">http-request deny if has_cl has_te</span>

<span style="color:var(--green)">Result: attack blocked at gateway ‚úì</span>
          </div>
        </div>
      </div>

      <div class="step defense">
        <div class="step-num">D4</div>
        <div class="step-content">
          <span class="tag green">RECOVERY</span><span class="tag yellow">PURGE</span>
          <h3>Cache Purge for Incident Recovery</h3>
          <p>Even after patching, old poisoned entries may remain in cache. The purge tool sends a PURGE request to Varnish to immediately invalidate compromised cache entries.</p>
          <div class="code">
<span style="color:var(--yellow)">python3 purge_cache.py</span>

PURGE /api/user HTTP/1.1
X-Purge-Key: purge-secret

‚Üí HTTP/1.1 200 Purged ‚úì
‚Üí Next request fetches fresh data from backend
<span style="color:var(--green)">‚Üí Cache clean, attack neutralized ‚úì</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- LIMITATIONS -->
  <div id="limits" class="panel">
    <div class="section-title">// <span>Project Limitations</span> ‚Äî ◊û◊í◊ë◊ú◊ï◊™ ◊î◊§◊®◊ï◊ô◊ß◊ò</div>

    <div class="limits-grid">
      <div class="limit-card">
        <h3>‚ö†Ô∏è HTTP/1.1 Only</h3>
        <p>The lab only demonstrates CL.TE smuggling over HTTP/1.1. HTTP/2 and HTTP/3 have different framing mechanisms and are not vulnerable to this specific attack variant.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è No TLS/HTTPS</h3>
        <p>The environment runs on plain HTTP. Real-world deployments use HTTPS ‚Äî while this doesn't prevent smuggling, it adds complexity to the attack setup not covered here.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è Local Environment Only</h3>
        <p>All attacks are performed on localhost via Docker. Real-world smuggling over the internet involves network latency, connection pooling, and load balancers that may behave differently.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è Single Backend Instance</h3>
        <p>The lab uses one Flask container. In production with multiple backends behind a load balancer, the smuggled request may hit a different backend than the victim's request.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è Simplified Auth Model</h3>
        <p>Admin access is controlled by a static header (X-Admin-Auth: secret-token). Real applications use session tokens, JWTs, or OAuth ‚Äî making the attack chain more complex.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è TE.CL Not Demonstrated</h3>
        <p>Only CL.TE (Content-Length front-end, Transfer-Encoding back-end) is shown. The reverse variant TE.CL exists and affects different proxy configurations.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è No Real User Simulation</h3>
        <p>Victim requests are simulated by Python scripts. In reality, attack timing depends on real user traffic patterns which are unpredictable.</p>
      </div>

      <div class="limit-card">
        <h3>‚ö†Ô∏è Development Server Warning</h3>
        <p>Flask runs in development mode (Werkzeug). Production deployments use WSGI servers (Gunicorn, uWSGI) which may handle connection buffering differently.</p>
      </div>
    </div>
  </div>

</div>

<script>
function showTab(id) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  event.target.classList.add('active');
}

// Make steps clickable to expand
document.querySelectorAll('.step').forEach(step => {
  step.addEventListener('click', function() {
    const wasActive = this.classList.contains('active');
    // Remove active from siblings
    this.parentElement.querySelectorAll('.step').forEach(s => {
      if (!s.classList.contains('defense')) s.classList.remove('active');
    });
    if (!wasActive && !this.classList.contains('defense')) {
      this.classList.add('active');
    }
  });
});
</script>
</body>
</html>